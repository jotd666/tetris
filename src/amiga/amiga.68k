*
*	Amiga-specific portions of Super Bagman
*
* (c) JOTD 2023
*

.include "../src/tetris.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1


* set direct draw: immediate update, possible tearing
OPT_DIRECT_DRAW = 0
	.ifeq	OPT_DIRECT_DRAW
OPT_ENABLE_DOUBLE_BUFFERING_BG = 0   | do not change!
	.else
	* if direct draw not set, can enable double buffering
OPT_ENABLE_DOUBLE_BUFFERING_BG = 1
	.endif
	
SCREEN_ADDRESS = 0x1000
PALETTE_ADDRESS = 0x2000


SCORE_FILE_SIZE = 0x90



	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	.else
OPT_ENABLE_LOGGING = 0
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1


	.endif
	


_custom = 0xDFF000

* FMODE=3 for faster chipmem access
AGA_FMODE = 1
NB_PLAYFIELD_PLANES = 8

LOGICAL_NB_BYTES_PER_ROW = 42
NB_BYTES_PER_ROW = 48
NB_LINES = 240
NB_PLAYFIELD_LINES = NB_LINES
NB_ROWS = NB_LINES/8

BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES


| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm


.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

start:
	move.l	a7,old_stack
	bra	_user
    
	

* exports

	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_disable_interrupts
		.global osd_enable_interrupts
		.global osd_break		| for debug	
		*.global osd_calibrate_display		| for debug
		.global osd_r_videoram
		.global osd_w_videoram
		.global osd_w_colorram

		.global osd_update_sprites
		.global osd_read_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_sound_start
		.global osd_sound_stop
		.global	osd_get_random
		.global	osd_wait
		.global	osd_set_palette_entry
		.global	osd_write_audio_pokey
		.global	osd_read_pokey1
		.global	osd_read_pokey2
		.global	osd_dump_file
		
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
	move.b	d1,_keyexit
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	move.l	#5,number_of_credits
	
	lea	read_args_string(pc),a0
	lea	program_args(pc),a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	

	bsr	get_args_BCPL

0:	
	lea		program_args,a0

2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#0x1,cheat_flags
2:
	move.l	(A0)+,D0	| NUMCREDITS/K
	beq.b	2f
	bsr		bcpl_string_to_int
	move.l	d0,number_of_credits
	nop
2:
	move.l	(A0)+,D0	| INFCREDITS/S
	beq.b	2f
	st		unlimited_credits_flag
	st		cheat_used
2:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	move.l	(A0)+,D0	| DOUBLEBUF/S/S
	beq.b	2f
	move.l	#1,double_buffering
	.endif
2:
	move.l	(A0)+,D0	| ALTWAVEFORM/S
	beq.b	2f
	move.l	#1,music_style
2:

	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	
	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)

	bsr		load_highscores

    * check if "floppy" file is here
    
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

.startup:

* no multitask
	.ifeq  OPT_ENABLE_DOUBLE_BUFFERING_BG
	clr.l	double_buffering
	.endif

    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

	
    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	move.l	number_of_credits,d0
	seq		unlimited_credits_flag
	move.b	d0,start_number_of_credits	| 0: game sets to 5

	tst.l	music_style
	beq.b	0f
	move.l	#tri_high_channel_table,high_channel_table
	move.l	#tri_very_high_channel_table,very_high_channel_table
	move.l	#tri_medium_channel_table,medium_channel_table
0:

	.ifne	0
	move.l	dip_switch_difficulty(pc),d0
	lsl.b	#3,d0
	

	move.l	misc_options,d1
	btst	#0,d1
	
	btst	#1,d1
	beq.b	0f
	bset	#5,d0
0:
	btst	#2,d1
	
	move.b	d0,dip_switches


	

	move.l	cheat_flags,d0
	btst	#0,d0
	
	btst	#1,d0
	
	btst	#2,d0
	
	btst	#3,d0
	.endif
	
	jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1

	jra		demo_game


* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer(pc),a1
    bsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    bsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	bsr.s call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase(pc),a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	lsl.w #2,d6
	move.l 0(a2,d6.w),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts

	
get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	
* To get the core to run, you just need to jump to tetris_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* 6502 reset. You also need to call tetris_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init

		lea			bank0_4000+0xF36,a0
		lea 		jotd_credits,a1
		move.w		#jotd_credits_end-jotd_credits-1,d0
0:
		move.b	(a1)+,(a0)+
		dbf		d0,0b

		* skip first 8 values, so random blocks aren't in the same line!
		.rept	8
		bsr		osd_get_random
		.endr
		
		*bsr		sound_test
		
		jmp			tetris_reset					| pass control to the tetris core
		
	
* just in case some hardware calls nmi
_nmi:
	move.w	#0x7FFF,_custom+intreq
	move.w	#0x7FFF,_custom+intreq
	rts
			
_int1:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5	
	move.w	#0x2700,SR		| don't let any other interrupt, as there is one shared irq routine
	clr.b	is_vblank
	* call IRQ for music (250 calls/second)
	jsr		tetris_irq

	lea		_custom,a5		
	move.w	#0x4,(intreq,a5)		| ack
	move.w	#0x4,(intreq,a5)		| ack
    movem.l (a7)+,d0-d7/a0-a6
	rte
	
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	st.b	is_vblank
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f

	moveq	#0,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state_2

	move.l	_joypad_state_1(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state_1
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick(pc),d1
	beq.b	13f
	
	subq	#1,d1

	move.w	d1,music_tick
	bne.b	13f
	bsr		osd_sound_stop
13:
	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	bra.b	3f
1:
	* has to be copper
	* we're going to ack copper interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x10,(intreq,a5)
	move.w	#0x10,(intreq,a5)
	
	* update screen
	.ifeq	OPT_DIRECT_DRAW
	jbsr		update_screen
	lea		_custom,a5
	.endif
	
	moveq	#ONE_TICK,d1
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
	clr.b	two_ticks
    cmp.w   #5,d0
    bne.b   22f
    * update a second time, simulate 60Hz
	st.b	two_ticks
	clr.w d0    
22:
	
	jbsr		tetris_irq
	tst.b	two_ticks
	beq.b	23f
	jbsr		tetris_irq	
23:
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_BG
	tst.b	double_buffering+3
	beq.b	24f
	bsr		switch_screen_buffers
24:
	.endif

	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	addq.b	#ONE_TICK,vb_ticks_count
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
    rte
	


osd_break:
	* sends a WinUAE command to enter WinUAE debugger
	.ifndef	RELEASE
	move.l	D0,-(a7)
	pea     0.w
	* Normally it would point to where the result of the command is written, but since the last parameter (first pushed)
	* indicating the number of bytes to write is 0, nothing is written.
	pea     0.w	
	pea     1003f-1002f
	pea     1002f(pc)
	pea     -1.w
	pea     82.w
	jsr     0xf0ff60
	lea     24(sp),sp
	move.l	(a7)+,d0
	.endif
    rts
		
1002: .asciz    "AKS_ENTERDEBUGGER 1"
1003:
        .align	2

* < A0.W: palette index
* < D0: new palette value
*  xxxxxxxx    Palette RAM
*  xxx----        (red component)
*  ---xxx--       (green component)
*  ------xx       (blue component)

osd_set_palette_entry:
	.ifndef	RELEASE
	cmp.w	#0x100,a0
	bcs.b	0f
	move.l	a0,a1
	lea		write_palette_out_of_range_error(pc),a0
	jbsr	osd_break
	.endif
0:
	move.w	d0,-(sp)
	movem.l	a0/a1,-(sp)
	* store raw palette color value (maybe re-read later?)
	lea		palette_entries,a1
	move.b	d0,(a1,a0.w)
	
	* get pointer on copperlist color entry
	lea		color_copper_pointers,a1
	add.w	a0,a0
	add.w	a0,a0
	move.l	(a1,a0.w),a0
	* a0 points on the RGB4 color in copperlist
	lea		color_table(pc),a1
	* decode color 8 bit => RGB4 using pre-computed table
	and.w	#0xFF,d0
	add.w	d0,d0
	move.w	(a1,d0.w),(a0)
	movem.l	(sp)+,a0/a1
	move.w	(sp)+,d0
	rts
	
	
osd_get_random:
	movem.l	d1-d3,-(a7)
	move.l	lfsr_index(pc),d0
	moveq	#0,d3
	moveq	#0,d2	| in8
	btst	#8,d0
	beq.b	0f
	bset	#7,d3
0:
	btst	#13,d0
	beq.b	0f
	bset	#7,d2
0:
	eor.b	d3,d2	| in8
	moveq	#0,d3
	btst	#0,d0
	beq.b	0f
	bset	#16,d3	| in
0:
	lsr.l	#1,d0
	and.w	#0xFF7F,d0
	or.b	d2,d0
	or.l	d3,d0
	move.l	d0,lfsr_index
	movem.l	(a7)+,d1-d3
	and.l	#0xFF,d0
	rts
	

* < D0: value to write
* < A0: address (minus 0x2800)
osd_write_audio_pokey:
	movem.l	d0-d5/a0/a1/a5/a6,-(a7)
	lea		_custom,a6
	moveq	#0,d5
	moveq	#0,d4
	move.w	a0,d1		| pokey offset

	btst	#4,d1
	beq.b	1f
	* second pokey
	bclr	#4,d1		| nullify bit 4 all is (28)0x now
	st.b	d4			| second pokey flag
1:
	* separate AUDF from AUDC now
	* AUDF addresses are even, AUDC addresses are odd
	lsr	#1,d1
	* now D1 is the channel number (0-3) or 4 (aud master ctl (28)x8)
	jcs	4f		| channel AUDC audio control for channel
	cmp.w	#4,d1
	jcc	5f		| main audio control (28)x8
	moveq	#0,d2

	move.b	d0,d2	| save frequency nibble
	move.w	d1,d5	| save channel
	lsr.w	#1,d5	| 16 bit channels: 2 channels per pokey
	moveq	#0,d0
	move.w	d1,d0		| channel
	
	lea		pokey_frequencies(pc),a0
	tst.b	d4
	beq.b	1f
	addq.w	#4,a0
	addq	#2,d5		| amiga channel 0-3
1:
	cmp.b	#3,d5
	beq.b	0f		| 4th channel is managed some other way, not music!
	
	* store freq nibble
	bchg	#0,d1
	cmp.b	(a0,d1.w),d2
	beq.b	0f			| same value as before, don't do anything
	move.b	d2,(a0,d1.w)

55:	
	* read full freq
	lea		pokey_frequencies(pc),a0
	move.w	(a0,d5.w*2),d2
	beq.b	3f
	
	moveq	#0,d1

	move.l		medium_channel_table(pc),a1
	move.b	#104,d1
	move.l		high_channel_table(pc),a1
	move.b	#56,d1

	* which waveform to use? low, medium, ... 
	* depending on value of D2
	cmp.w	#0x300,d2
	bcc.b	1f
	* switch to very high
	move.l		very_high_channel_table(pc),a1
	move.b	#65/2,d1

1:
	move.w	d2,d0		| save it
	lsl.l	#4,d2
	
	divu	d1,d2

	* don't stop loop now it only makes things worse
	
	* if pokey_master_control is not 0x78 don't play tune
	
*	lea	pokey_master_control(pc),a0
*	tst.b	d4
*	beq.b	11f
*	addq	#1,a0		| second pokey
*11:
*	cmp.b	#0x78,(a0)
*	jeq		12f			| normal 16-bit musical sound
*	* noise: drum, not supported ATM
*	cmp.b	#0x50,(a0)
*	jeq	0f

	move.l	(a1,d5.w*4),a0
	* set full frequency
	
	cmp.w	#124,d2
	bcs.b	0f			| bogus frequency, skip
2:
	*lea	pokey_channel_control(pc),a1
	*move.b	(a1,d5.w),d1
	*and.w	#0xF,d1
	*beq.b	0f
	*lsl.w	#1,d1	| amp from 16 to 32 max
	move.w	#28,d1	| fixed for if no sound if I use channel control value
	move.w	d1,(se_soundvol.w,a0)
	move.w	d2,(se_soundfreq.w,a0)
	moveq	#0,d0
	move.b	d5,d0		| channel
	jsr		_mt_loopfx
	
0:
	movem.l	(a7)+,d0-d5/a0/a1/a5/a6
	rts
3:
	move.b	d5,d0		| amiga channel
	jsr		_mt_stopfx
	bra.b	0b

4:
	* channel control: D1 contains channel 0-3
	* but channels are joint so merge controls
	* actually, in-game only addresses 2803, 2807, 2813 contain
	* something or 0, rest is 0.
	lsr	#1,d1
	bcc.b	0b		| even address: no need to consider
	* d4 set: second pokey
	tst.b	d4
	beq.b	41f
	addq	#2,d1
41:
	and.w	#0xFF,d1
	cmp.w	#3,d1
	bcc.b	0b		| 4th channel is SFX don't touch
	move.w	d1,d5
	lea	pokey_channel_control(pc),a0
	move.b	(a0,d5.w),d2		| save old value
	move.b	d0,(a0,d5.w)
	bne.b	7f
	* channel control to 0: stop sound
	move.b	d1,d0		| amiga channel
	jsr		_mt_stopfx
	bra.b	0b
7:
	cmp.b	d2,d0
	* if old value is not new value, play note again
	jne	55b
	bra.b	0b
5:
	* main control
	lea	pokey_master_control(pc),a0
	tst.b	d4
	beq.b	6f
	addq	#1,a0		| second pokey
6:
	move.b	d0,(a0)		| new value update
	bra.b	0b
	
	* the only inreresting thing here is VBLANK flag
	* because there's only one IRQ vector for both IRQ interupts
	*
	* "fast" IRQ 250 times/second
	* vblank IRQ 60 times/second

osd_read_pokey1:
	moveq	#0,d0
	tst.b	is_vblank
	bne.b	0f
	* not vblank: set VBLANK bit (apparently inverted logic)
	bset	#6,d0
0:
	rts
	
	move.l	a0,-(a7)
	lea		keyboard_table(pc),a0
	tst.b	(5,a0)
	beq.b	0f
	clr.b	(5,a0)
	bset	#2,d0		| insert coin
0:
	move.l	(a7)+,a0
	rts
	
osd_read_pokey2:
	moveq	#0,d0
	movem.l	d1/a0,-(a7)
	lea		keyboard_table(pc),a0

	* 2P start: bit 4
	
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bset	#3,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bset	#2,d0
0:
	tst.b	(0x4D,a0)		| "down" key
	beq.b	0f
	bset	#1,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bset	#0,d0
0:
	tst.b	(0x66,a0)		| "alt" key
	beq.b	0f
	bset	#4,d0
0:
	* directions + fire
	move.l	_joypad_state_1(pc),d1

	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bset	#1,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bset	#3,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bset	#2,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bset	#0,d0
0:
	move.l	_joypad_state_2(pc),d1

	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bset	#5,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bset	#7,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bset	#6,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bset	#4,d0
0:

	movem.l	(a7)+,d1/a0
	rts
	


	
osd_sound_start:
	movem.l	d0/d1/a0/a6,-(a7)
	and.w	#0xFF,d0
	lea		_custom,a6
	
	
	lsl.w	#3,d0
	lea		sound_table,a0

	move.w	(a0,d0.w),d1	| sound type
	beq.b	0f		| no sound


	move.w	(2,a0,d0.w),d1
	move.l	(4,a0,d0.w),a0
	lea		_custom,a6
	jsr		_mt_playfx
0:
	movem.l	(a7)+,d0/d1/a0/a6
	rts

osd_sound_stop:
	movem.l	d0/a0/a6,-(a7)
	lea		_custom,a6
	move.b	#-1,music_track_start_number
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
    jsr		_mt_end
0:
	movem.l	(a7)+,d0/a0/a6
	rts
	


	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
switch_screen_buffers:	
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	lea		bg_drawed_screen_ptr(pc),a0
	lea		bg_displayed_screen_ptr(pc),a4
	move.l		bg_screen_data_ptr_1,a1
	move.l		bg_screen_data_ptr_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
2:
	move.l	a1,(a0)
	move.l	a5,(a4)
	jbsr		set_bg_bitplanes
	
	rts
	.endif

	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5

	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	
*	move.w	AttnFlags(a6),d0
*	btst	#AFB_68020,d0
*	bne.b	1f
*	* no whdload, no 68020: assume slow
*	* if running on PiStorm, well, too bad use whdload
*	st.b	slow_machine
*1:
	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(0x64,a1),(a0)+
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	move.l	(0x7C,a1),(a0)+
	rts

restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(a0)+,(0x64,a1)
	move.l	(a0)+,(0x68,a1)
	move.l	(a0)+,(0x6c,a1)
	move.l	(a0)+,(0x70,a1)
	move.l	(a0)+,(0x74,a1)
	move.l	(a0)+,(0x78,a1)
	move.l	(a0)+,(0x7C,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	tst.l	_resload
	bne.b	0f
	bsr		restore_system
	* set SR to 0 from here, so we return to OS with SR=0
	* (else it kills the system pretty quickly)
	* it works as quit_to_os is called from an interrupt
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
0:
	pea	  TDREASON_OK
	move.l	_resload(pc),-(a7)
	addq.l	#resload_Abort,(a7)
	rts

platform_init:
	bsr		store_system
	

	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
	.ifndef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  #-1,bltafwm(a5)
	.endif

    move.w #0x2e77,diwstrt(a5)
    move.w #0x1ec7,diwstop(a5)
	

	.ifdef	AGA_FMODE
    move.w #0x0030,ddfstrt(a5)
    move.w #0x00C0,ddfstop(a5)
	* AGA-compatible ECS default values
    move.w #3,fmode(a5)			
    move.w #0xcc66,bplcon1(a5)    | foreground tiles
	move.w	#0,d0
	.else
    move.w #0x0030,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
	* AGA-compatible ECS default values
    move.w #0,fmode(a5)			
    move.w #0x0066,bplcon1(a5)    | foreground tiles
	move.w	#6,d0
	.endif
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)
	
	
    move.w #0x0210,bplcon0(a5) | 8 bitplanes
    move.w #0x0024,bplcon2(a5)
    move.w #0x0C00,bplcon3(a5)     | no AGA specificities, default ECS


	* init color table
	lea		copperlist_colors+2,a0
	lea		color_copper_pointers,a1
	moveq	#NB_PLAYFIELD_PLANES-1,d0
0:
	addq.w	#4,a0
	move.w	#31,d1
1:
	move.l	a0,(a1)+
	addq.w	#4,a0
	dbf		d1,1b
	dbf		d0,0b
	

	
	* set other sprites to blank
	move.l		#blank_sprite,d0

	moveq	#7,d1
	lea		sprites,a1
0:
    move.w	d0,(6,a1)
	swap	d0
    move.w	d0,(2,a1)
	swap	d0
	addq.w	#8,a1
	dbf		d1,0b
	
	lea	bg_screen_buffer_1,a0
	addq	#8,a0
	move.l	a0,d0
	and.w	#0xFFF8,d0
	move.l	d0,a0
	move.l	a0,bg_drawed_screen_ptr
	move.l	a0,bg_screen_data_ptr_1
	move.l	a0,bg_screen_data_ptr_2
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	tst.l	double_buffering
	beq.b	0f
	lea	bg_screen_buffer_2,a0
	addq	#8,a0
	move.l	a0,d0
	and.w	#0xFFF8,d0
	move.l	d0,a0
	move.l	a0,bg_screen_data_ptr_2
	.endif
0:
	move.l	a0,bg_displayed_screen_ptr
	
	bsr		set_bg_bitplanes
	
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)

	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
    *move.w #0x20,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	system_vbr(pc),a1
	move.l	(a7)+,(0x68,a1)
	pea		_int1(pc)
	move.l	(a7)+,(0x64,a1)
	pea		_vblank(pc)
	move.l	(a7)+,(0x6C,a1)
	pea		_nmi(pc)
	move.l	(a7)+,(0x7C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr(pc),a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia
	
    rts

	
* dump file to disk, debug only
* < A0: filename
* < A1: memory
* < D0: length

osd_dump_file:
	tst.l	_resload
	bne.b	0f
	* not available under amigaOS
	rts
0:
	movem.l	d0-d1/a0-a2,-(a7)
	move.l	_resload(pc),a2
	jbsr	(resload_SaveFile,a2)
	movem.l	(a7)+,d0-d1/a0-a2
	rts
	
	
* enable 60Hz VBLANK interrupt & level 1 (also keyboard)
osd_enable_interrupts:
	move.w	#0xC03C,_custom+intena
	rts

		
* disable 60Hz VBLANK interrupt & level 1
osd_disable_interrupts:
	move.w	#0x0034,_custom+intena
	rts

	
* < A0=screen address (preserved)
* (A0 starts at 0x1000 and ends at 0x1FFF)
* > D0: code
* should preserve all registers

osd_r_videoram:
	movem.l	a0-a1,-(a7)
	
	cmp.w	#SCREEN_ADDRESS,a0
	bcs.b	0f
	cmp.w	#PALETTE_ADDRESS,a0
	bcs.b	1f
0:
	* should not happen
	.ifndef	RELEASE
	move.l	a0,a1
	lea		read_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	.endif
	
	bra.b	0f
	
1:
	sub.w	#SCREEN_ADDRESS,a0
	lea		bg_videoram,a1
	add.w	a0,a1
	
	move.b	(a1),d0
0:
	movem.l	(a7)+,a0-a1
	tst.b	d0	| very important as it replaces a lda
	rts

	.ifeq	OPT_DIRECT_DRAW
* called once in bottom of frame so dirty tiles are rewritten there and
* not directly, to avoid tearing (possible double buffering too with that method)
*
* relies on the fact that update_tile doesn't destroy
* "high" address & data registers, no register save is required
* for faster operation
update_screen:
	lea		dirty_line_list(pc),a6
	move.w	#0,d7
0:
	tst.b	(a6,d7.w)
	beq.b	5f
	* ack line
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	subq.b	#1,(a6,d7.w)
	.else
	clr.b	(a6,d7.w)	
	.endif
	
	lea		bg_videoram,a4
	lea		dirty_rows_array(pc),a5
	move.w	d7,d4
	lsl.w	#6,d4		| times 64
	add.w	d4,a5
	add.w	d4,a4
	add.w	d4,a4		| times 128
	moveq	#0,d6		| column index
1:
	tst.b	(a5)+
	beq.b	2f
	* needs update
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	subq.b	#1,(-1,a5)		| ack tile
	.else
	clr.b	(-1,a5)		| ack tile
	.endif
	* get 16-bit word for tile&color
	move.w	(a4),d0
	move.w	d4,d1		| line offset
	add.w	d6,d1		| column offset
	jbsr		update_tile
2:
	addq	#2,a4
	addq	#1,d6
	cmp.w	#LOGICAL_NB_BYTES_PER_ROW,d6
	bne.b	1b
5:
	* next row
	addq	#1,d7
	cmp.w	#NB_ROWS,d7
	bne.b	0b
	
	rts

	.endif

* < A0=screen address (preserved)
* (A0 starts at 0x1000 and ends at 0x1FFF)
* < D0: code
* should preserve all registers

osd_w_colorram:
	movem.l	d0-d3/d6/a0-a2,-(a7)
	
	cmp.w	#SCREEN_ADDRESS,a0
	bcs.b	0f
	cmp.w	#PALETTE_ADDRESS,a0
	bcs.b	1f
0:
	* should not happen
	.ifndef	RELEASE
	move.l	a0,a1
	lea		write_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	.endif
	
	bra.b	0f
	
1:
	sub.w	#SCREEN_ADDRESS,a0
	lea		bg_videoram,a1
	add.w	a0,a1

	move.b	d0,(a1)	| update logical grid
	move.l	a1,d0
	.ifndef	RELEASE
	btst	#0,d0
	bne.b	1f
	lea		write_colorram_called_on_even_address(pc),a0
	jbsr	osd_break
	bra.b	0f
1:
	.endif
	
	move.w	a0,d1		| address offset
	lsr.w	#1,d1		| offset /= 2

	.ifne	OPT_DIRECT_DRAW
	* draw tile now (induces tearing on slow machines)
	bclr	#0,d0
	move.l	d0,a1
	* get 16-bit word for tile&color
	move.w	(a1),d0

	jbsr		update_tile
	.else	

	* mirrors video RAM layout (only 1 byte per tile, not 2)
	lea		dirty_rows_array(pc),a0
	* double buffering needs 2 updates when a change is made
	move.b	double_buffering+3(pc),d0
	addq.b	#1,d0
	move.b	d0,(a0,d1.w)
	
	* just mark row & col as dirty so lookup will be faster
	* only test row if row flag is set
	lea		dirty_line_list(pc),a0
	lsr.w	#6,d1			| 64 bytes per row
	move.b	d0,(a0,d1.w)
	
	.endif
	
0:
	movem.l	(a7)+,d0-d3/d6/a0-a2
	rts
	
* < A0=screen address (preserved)
* (A0 starts at 0x1000 and ends at 0x1FFF)
* < D0: code
* should preserve all registers

osd_w_videoram:
	movem.l	d0-d3/d6/a0-a2,-(a7)
	
	cmp.w	#SCREEN_ADDRESS,a0
	bcs.b	0f
	cmp.w	#PALETTE_ADDRESS,a0
	bcs.b	1f
0:
	* should not happen
	.ifndef	RELEASE
	move.l	a0,a1
	lea		write_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	.endif
	bra.b	2f
1:
	lea		bg_videoram-SCREEN_ADDRESS,a1
	move.b	d0,(a1,a0.w)	| update logical grid
2:
	movem.l	(a7)+,d0-d3/d6/a0-a2
	rts

	
* < D0.W: tile+color 
* < D1.W: screen offset
update_tile:
	move.w	d0,d2
	ror.w	#8,d0		| invert bytes
	and.w	#0x07FF,d0	| 2048 tiles: tile index
	and.w	#0xF0,d2
	lsr.w	#4,d2		| tile CLUT (ignored ATM)
	
	.ifne	OPT_ENABLE_LOGGING
	* when logging is enabled, play a while
	* and break. Get the address in 0x100 then do
	* S used_cluts <address at $100> $10000
	* then run the compute_used_cluts.py program again
	
	lea		tile_log_table,a0
	move.l	a0,0x100
	movem.w	d0-d1,-(a7)
	and.l	#0xFFFF,d0
	lsl.l	#8,d0
	add.w	d1,d0
	st.b	(a0,d0.l)
	movem.w	(a7)+,d0-d1
	.endif
	
	* layout is simple: X = offset % 0x40
	*                   Y = offset // 0x40
	move.w	d1,d3
	and.w	#0x3F,d1	| X
	cmp.w	#LOGICAL_NB_BYTES_PER_ROW,d1
	jcc		0f			| last tiles are invisible
	lsr.w	#6,d3		| Y
	
	lea		mulNB_BYTES_PER_ROW_table(pc),a0

	
	move.l	bg_drawed_screen_ptr(pc),a1
	* D3 = Y

	add.w	d3,d3
	move.w	(a0,d3.w),d3
	lsl.w	#3,d3		| times 8
	add.w	d3,a1
	add.w	d1,a1


*	* optimization when a well-known
*	* empty character is passed (standard charset)
*	* doesn't seem to depend on the attribute
*	cmp.w	#0xE0,d0	| empty character
*	jeq	11f
*	cmp.w	#0x1E0,d0	| empty character
*	jeq	11f
*	cmp.w	#0x3E0,d0	| empty character
*	jeq	11f
*	cmp.w	#0x10,d0	| empty character
*	jeq	11f

	lea		character_table,a0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	2f				| isn't declared as used
	move.l	d0,a0		| pointer on clut table
	* now we use d2 (attribute) to get relative pointer on list of bitplanes
	add.w	d2,d2
	add.w	(a0,d2.w),a0
	cmp.l	d0,a0
	jeq		12f		| should not happen

	moveq	#NB_PLAYFIELD_PLANES-1,d3
	move.l	a0,a2
	lea		planes_table,a3
3:
	moveq	#0,d0
	move.w	(a2)+,d0    | plane data index
	bmi.b	6f
	lsl.l	#3,d0		| times 8
	lea		(a3,d0.l),a0	| AT LEAST!! get address of plane data

	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset,a1)	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
5:
	add.w	#BG_SCREEN_PLANE_SIZE,a1
	dbf		d3,3b
	rts
0:
	rts

6:
	* clear tile
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	bra.b	5b
	
11:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	add.w	#BG_SCREEN_PLANE_SIZE,a1
	dbf		d3,11b
2:
	rts

12:
	* clut/tile combo not declared as used
	**blitz
	rts


			

	
* set_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    move.l	bg_displayed_screen_ptr(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	bg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #BG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts


osd_read_dipswitches:
	* actual dipswitches
	move.b	dip_switches(pc),d0
	not.b	d0		| active low
	

	rts
	



		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	a0,a4
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	a0,a3
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	1f
	bsr		get_hiscore_name
	move.l	a3,a1
	jsr		resload_LoadFile(a2)
	* set highest score entry
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	1f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	* set highest score entry
	move.w	#SCORE_FILE_SIZE-1,d0
0:
    move.b    (a1)+,(a4)+
	dbf		d0,0b
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	tst.b	cheat_used		| don't save score if cheat on
	bne.b	1f
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	move.l	a0,a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a0)+,(a1)+
	dbf		d0,0b

	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts

se_soundfreq = 6
se_soundvol = 8

	
	
	.include	"sound_entries.68k"
	
    .macro    WAVEFORM_ENTRY    sound_name,size,channel,soundfreq,volume,priority
\sound_name\()_sound_\channel:
    .long    \sound_name
    .word   \size/2
    .word   \soundfreq,\volume
    .byte    \channel
    .byte    \priority
    .endm
	
	WAVEFORM_ENTRY		TRI_WFORM_MEDIUM,28,0,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_MEDIUM,28,1,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_MEDIUM,28,2,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_MEDIUM,28,3,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_HIGH,16,0,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_HIGH,16,1,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_HIGH,16,2,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_HIGH,16,3,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_VERYHIGH,10,0,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_VERYHIGH,10,1,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_VERYHIGH,10,2,400,64,1
	WAVEFORM_ENTRY		TRI_WFORM_VERYHIGH,10,3,400,64,1

	WAVEFORM_ENTRY		SQU_WFORM_MEDIUM,28,0,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_MEDIUM,28,1,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_MEDIUM,28,2,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_MEDIUM,28,3,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_HIGH,16,0,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_HIGH,16,1,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_HIGH,16,2,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_HIGH,16,3,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_VERYHIGH,10,0,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_VERYHIGH,10,1,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_VERYHIGH,10,2,400,64,1
	WAVEFORM_ENTRY		SQU_WFORM_VERYHIGH,10,3,400,64,1

tri_medium_channel_table:
	.long	TRI_WFORM_MEDIUM_sound_0
	.long	TRI_WFORM_MEDIUM_sound_1
	.long	TRI_WFORM_MEDIUM_sound_2
	.long	TRI_WFORM_MEDIUM_sound_3
tri_high_channel_table:
	.long	TRI_WFORM_HIGH_sound_0
	.long	TRI_WFORM_HIGH_sound_1
	.long	TRI_WFORM_HIGH_sound_2
	.long	TRI_WFORM_HIGH_sound_3
tri_very_high_channel_table:
	.long	TRI_WFORM_VERYHIGH_sound_0
	.long	TRI_WFORM_VERYHIGH_sound_1
	.long	TRI_WFORM_VERYHIGH_sound_2
	.long	TRI_WFORM_VERYHIGH_sound_3
	
squ_medium_channel_table:
	.long	SQU_WFORM_MEDIUM_sound_0
	.long	SQU_WFORM_MEDIUM_sound_1
	.long	SQU_WFORM_MEDIUM_sound_2
	.long	SQU_WFORM_MEDIUM_sound_3
squ_high_channel_table:
	.long	SQU_WFORM_HIGH_sound_0
	.long	SQU_WFORM_HIGH_sound_1
	.long	SQU_WFORM_HIGH_sound_2
	.long	SQU_WFORM_HIGH_sound_3
squ_very_high_channel_table:
	.long	SQU_WFORM_VERYHIGH_sound_0
	.long	SQU_WFORM_VERYHIGH_sound_1
	.long	SQU_WFORM_VERYHIGH_sound_2
	.long	SQU_WFORM_VERYHIGH_sound_3
	
medium_channel_table:
	.long	squ_medium_channel_table
high_channel_table:
	.long	squ_high_channel_table
very_high_channel_table:
	.long	squ_very_high_channel_table
	
level2_interrupt:
	bsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table(pc),a0
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    jne   2f     | we don't care about key release
	
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:

	btst	#0,cheat_flags+3
	jeq		10f
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	st.b	cheat_used
	* complete level - player 1
	lea		game_ram+0x30,a0
	move.b	#0x30,(a0)+
	move.b	#0x30,(a0)
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	st.b	cheat_used
	* complete level - player 2
	lea		game_ram+0x32,a0
	move.b	#0x30,(a0)+
	move.b	#0x30,(a0)
	

0:
10:
	.ifndef	RELEASE
	cmp.b	#0x58,d0	| F9 key crashes game (restarts whdload)
	bne.b	0f
	illegal
	.endif
0:

	cmp.b	_keyexit,d0	| "ESC" key or whdload quitkey
	bne.b	2f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
2:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
toggle_pause:
	* pause only within game
*	tst.b	gameplay_allowed_6054
*	beq.b	0f
*	tst.b	check_scenery_disabled_61ED
*	bne.b	0f
*	tst.b	game_locked_6053
*	bne.b	0f
	eor.b   #1,pause_flag
0:
	rts
	
    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

	
	MUL_TABLE	NB_BYTES_PER_ROW,NB_LINES

	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"CHEATKEYS/S,NUMCREDITS/K,INFCREDITS/S,DOUBLEBUF/S,ALTWAVEFORM/S"
read_args_string_end:

	.ifndef	RELEASE
sprite_allocation_error:
	.asciz	"sprite allocation error"
sprite_doesnt_exist_error:
	.asciz	"sprite doesn't exist"
sprite_buffer_doesnt_exist_error:
	.asciz	"sprite buffer doesn't exist"
read_videoram_out_of_range_error:
	.asciz	"read videoram out of range"
write_videoram_out_of_range_error:
	.asciz	"write videoram out of range"
write_palette_out_of_range_error:
	.asciz	"write palette out of range"
read_palette_out_of_range_error:
	.asciz	"read palette out of range"
write_colorram_called_on_even_address:
	.asciz	"write colorram on even address"

	.endif
	.align	2
	.include	"color_lut.68k"


old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	10
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0

	
	
_tag:
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0

		.long	WHDLTAG_CUSTOM2_GET
number_of_credits:
		.long	0
		.long	WHDLTAG_CUSTOM3_GET
music_style:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
double_buffering:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switch_start_lives:
		.long	0
	.long	0
dip_switches:
		.byte	0x20	| default english
		.byte	0

system_vbr:
	.long	0
	
orig_color_4:
	.word	0
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
is_vblank:
	.byte	0
	.align	2

keyboard_table:
	ds.b	0x100


pause_flag:
	.word	0

	* sound variables
music_duration:
	.word	0
music_track_start_number:
	.word	0
music_pattern:
	.word	0
music_tick:
	.word	0
intro_music_counter:
	.word	0
vbl_counter:
	.word	0
two_ticks:
	.word	0
_resload:
	.long	0
_joypad_state_1:
	.long	0
_joypad_state_2:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
delay_timer:
	.word	0
one_out_of_five:
	.word	0
bg_drawed_screen_ptr:
	.long	0
bg_displayed_screen_ptr:
	.long	0

lfsr_index:
	dc.l	(1<<17)-1

bg_screen_data_ptr_1:
	.long	0
bg_screen_data_ptr_2:
	.long	0
	
_keyexit:
	.byte	0x45	| ESC by default unless whdload overwrites it
music_loops:
	.byte	0
music_volume:
	.byte	0
music_playing:
	.byte	0
music_muted:
	.byte	0
dynamic_color_mode:
	.byte	0

cheat_used:
	.byte	0
jotd_credits:
	.ascii	"AMIGA VE;SION BY JOTD 2024"
jotd_credits_end:
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
normal_hiscorename:
	.asciz	"tetris.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
temp_filename_buffer:
	ds.b	255
	
	
pokey_master_control:
	.byte	0,0
	.align	2
pokey_channel_control:
	.long	0
pokey_frequencies:
	.word	0
	.word	0
	.word	0
	.word	0
_end_of_ng_code:
		
	.align 2
dirty_line_list:
	ds.b	NB_ROWS
dirty_rows_array:
	ds.b	0x40*NB_ROWS

color_copper_pointers:
	ds.l	256

	.ascii	"CODE_END"

	.align	8

	.section	.datachip
	.align	8
	
.macro	DECL_BITPLANES	bpoff_start
	.set	bpoff,\bpoff_start
	.rept	NB_PLAYFIELD_PLANES
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+4
	.endr
	.endm


.macro	DECL_32_COLORS
	.set	colidx,0
	.rept	32
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm
	
	
	
blank_sound:
	ds.l	4
	
debug_copperlist:
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
blank_sprite:
	.rept	32
	.long	0
	.endr
	
	
	* main copperlist
copperlist:

	.set	bpl_count,0
	
bg_bitplanes:
	DECL_BITPLANES	0
copperlist_colors:
	.rept	8
	.word	bplcon3,bpl_count<<13
	.set	bpl_count,bpl_count+1
	DECL_32_COLORS
	.endr

	.macro	MUSIC_INTERRUPT
	.word	intreq
	.word	0x8004
	.endm
	
sprites:
    * #0
    .word    sprpt+0,0
    .word    sprpt+2,0
    * #1
    .word    sprpt+4,0
    .word    sprpt+6,0
    * #2
    .word    sprpt+8,0
    .word    sprpt+10,0
    * #3
    .word    sprpt+12,0
    .word    sprpt+14,0   
    * #4
    .word    sprpt+16,0
    .word    sprpt+18,0
    * #5
    .word    sprpt+20,0
    .word    sprpt+22,0
    * #6
    .word    sprpt+24,0
    .word    sprpt+26,0
    * #7
    .word    sprpt+28,0
    .word    sprpt+30,0

	* music
	* trigger level 1 interrupt then wait 51 lines 
	* (faster than vblank, for music)
	*MUSIC_INTERRUPT
	* wait 51 lines
	.word	0x3301,0xFFFE
	MUSIC_INTERRUPT
	* wait 51 lines
	.word	0x6601,0xFFFE
	MUSIC_INTERRUPT
	.word	0x9901,0xFFFE
	MUSIC_INTERRUPT
	.word	0xCC01,0xFFFE
	
	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait
 	
	MUSIC_INTERRUPT
	

    *.word   0x1C01,0xFFFE
	*.set    beampos,0x1E01
	
	* set interrupt as soon as reached 256 lines
	* this will avoid some possible screen tearing
    .word	 intreq,0x8010
	
    .long    -2					
	.ascii	"ENDCPLST"

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
	
TRI_WFORM_MEDIUM:
	dc.b	0,0
	dc.b	00,-10,-20,-30
	dc.b	-40,-50,-60,-70
	dc.b	-60,-50,-40,-30
	dc.b	-20,-10,00,10
	dc.b	20,30,40,50
	dc.b	60,70,60,50
	dc.b	40,30,20,10


TRI_WFORM_HIGH:
	dc.b	0,0
	dc.b	00,20,40,70,40,20,0
	dc.b	-20,-40,-60,-70,-60,-40,-20


TRI_WFORM_VERYHIGH:
	dc.b	0,0
	dc.b	00,35,70,35,0,-35,-70,-35


SQU_WFORM_MEDIUM:
	dc.b	60,60,60,60
	dc.b	60,60,60,60
	dc.b	60,60,60,60
	dc.b	60,60,60,60
	dc.b	30,00,00,-30
	dc.b	-60,-60,-60,-60
	dc.b	-60,-60,-60,-60
	dc.b	-60,-60,-60,-60
	dc.b	-60,-60,-60,-60


SQU_WFORM_HIGH:
	dc.b	60,60,60,60,60,60,30
	dc.b	-30,-60,-60,-60,-60,-60,-60
	

SQU_WFORM_VERYHIGH:
	dc.b	50,60,30,0,-30,-60,-50
	
	
		.section .bsschip

bg_screen_buffer_1:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	ds.b	8		| for alignment
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_BG
bg_screen_buffer_2:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	ds.b	8		| for alignment
	.endif
	.align	8

		